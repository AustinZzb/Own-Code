/*
 * 标题: 黄金连分数
 * 黄金分割数0.61803... 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。
 * 对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!
 * 言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。
 * 比较简单的一种是用连分数：
 *             1
 *黄金数 = ---------------------
 *					1
 *		 1 + -----------------
 *					   1
 *			 1 + -------------
 *					     1
 *				 1 + ---------
 *					 1 + ...
 * 
 * 这个连分数计算的“层数”越多，它的值越接近黄金分割数。
 * 请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。
 * 小数点后3位的值为：0.618
 * 小数点后4位的值为：0.6180
 * 小数点后5位的值为：0.61803
 * 小数点后7位的值为：0.6180340
 * （注意尾部的0，不能忽略）
 * 你的任务是：写出精确到小数点后100位精度的黄金分割值。
 * 注意：尾数的四舍五入！ 尾数是0也要保留！
 * 显然答案是一个小数，其小数点后有100位数字，请通过浏览器直接提交该数字。
 * 注意：不要提交解答过程，或其它辅助说明类的内容。
 *  注意：由于黄金分割数是无限小数，所以在使用BigDecimal的除法时，要对结果进行精度的限制，否则BigDecimal的结果对象将是无限位的小数，导致报错。
 *  连分数的层数设置的大一点，一开始设置100，之后设置200，逐步设置，直到答案不再变化为止(保证100位的精确度)。以下两个程序都是直接设置的1000.
 *
 */
package 经典算法;

import java.math.BigDecimal;

/**
 * @author 张致邦
 *
 * 2020年3月12日-下午9:41:06
 */
public class _黄金连分数 {

	/**
	 * @param 将问题转换为斐波那契  和   大数运算
	 * 精确100的含义是将斐波那契额的n增大，直到前100位稳定为止
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		BigDecimal a = BigDecimal.ONE;
		BigDecimal b = BigDecimal.ONE;
		for (int i = 0; i < 400; i++) {
			BigDecimal temp = b;
			b = a.add(b);
			a = temp;
		}
		// 对斐波那契额数列的n和n+1项进行商运算，注意BigDecimal的精确位数， 和取舍参数
		BigDecimal ans = a.divide(b, 110, BigDecimal.ROUND_HALF_DOWN);
		System.out.println(ans.toPlainString().substring(0, 103));
		// 最后的计算结果为  			0.61803398874989484820458683436563811772030917980576286213544862270526046281890244970720720418939113748
		// 但是结果需要四舍五入！！！	0.6180339887498948482045868343656381177203091798057628621354486227052604628189024497072072041893911375
	}

}



























